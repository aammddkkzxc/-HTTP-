### HTTP 메서드
- 가장 중요한 기준 -> 리소스
- 보통 계층 구조상 상위를 컬렉션으로 인식하고 복수 단어 사용을 권장한다. 즉 user 보단 users를 사용
- 조회, 등록, 수정, 삭제가 모두 같은 리소스
- 리소스와 리소스를 대상으로 하는 행위를 분리
    - 리소스 : 회원 → 명사
    - 행위 : 조회, 등록, 삭제, 변경 → 동사

### HTTP 메서드의 종류
- `GET` : 리소스 조회
    - 리소스 조회
    - 서버에 전달하고자 하는 데이터는 `query(쿼리 파라메터, 쿼리 스트링)`를 통해서 전달
    - GET 요청 또한 메시지 바디를 통해서도 데이터를 전달할 수 있지만 지원하지 않는 서버가 많다.
    
- `POST`: 요청 데이터 처리, 주로 등록에 사용
    - 요청 데이터를 처리
    - 메시지 바디를 통해 서버로 요청 데이터 전달
    - 서버에서 요청 데이터 처리
        - 메세지 바디를 통해 들어온 데이터를 처리하는 모든 기능 수행
    - 전달된 데이터로 `신규 리소스 등록`, `프로세스 처리`에 사용
    - 등록 시 201 Created, Location 헤더(자원이 생성된 path)를 보내 줌.
    - post 메서드는 대상 리소스가 리소스의 고유한 의미 체계에 따라 요청에 포함된 표현을 처리하도록 요청 (구글 번역 정의)
    - 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 함 -> 정해진 것이 없.
        1. 새 리소스 생성(등록)
        2. 요청 데이터 처리
            - 데이터 생성, 변경을 넘어 프로세스를 처리해야 하는 경우
            - 값 변경을 넘어 프로세스의 상태가 변경되는 경우 (예, 결제 완료 -> 배달 시작 -> 배달 완료)
            - POST의 결과로 새 리소스가 생성되지 않을 수도 있음.
            - 컨트롤 uri
                - POST /orders/{orderId}/start-delivery
                → 동사의 uri를 control uri라고 함. 최대한 리소스로 uri를 설계하지만 어쩔수 없는 경우가 있음.
        3. 다른 메서드로 처리하기 애매한 경우
            - JSON으로 조회 데이터를 넘겨야 하는데, get 메서드를 사용하기 어려운 경우 (get 메서드 의 경우 message body를 허용하지 않는 경우가 많다)
            - 조회이지만 POST를 사용할 수 있음.
            - 애매하면 POST
            - GET으로 오는 경우는 캐싱을 할 수 있지만, POST의 경우는 캐싱을 하기가 어려운 단점이 있다.       
- `PUT`: 리소스를 대체, 해당 리소스가 없으면 생성
    - 리소스가 `있으면 대체, 없으면 생성`. 즉, 덮어버린다.
    - 클라이언트가 리소스를 식별
        - 클라이언트가 리소스 위치를 알고 URI 지정 (/members/100)
        - POST와의 차이점
    - 리소스를 완전히 대체한다.
        - username, age 필드가 있을때 age 필드만 넣을 수 없다.
        - age 필드만 넘기게 되면 username 필드가 사라지게 된다.  
- `PATCH`: 리소스 부분 변경
    - 리소스 부분 변경
    - username, age 필드가 있을 때 age 필드만 수정 가능하다.
    - PATCH가 지원이 안되는 서버가 있을 수 있다. 그러한 경우는 POST를 사용해 주면 된다.
- `DELETE`: 리소스 삭제
    - 리소스 제거
- HEAD: GET과 동일하지만 메시지 부분을 제외하고 상태 줄과 헤더만 반환(body 빼고) (응답에)
- OPTIONS: CORS에서 사용, 대상 리소스에 대한 통신 가능 옵션

### HTTP 메서드의 속성

1. `안전(Safe)`
    - 호출해도 **리소스를 변경하지 않는다.**
    - 그래도 계속 호출해서 로그 같은게 쌓여서 장애가 발생하면?
    - 안전은 `해당 리소스만 고려`한다.
    - GET, HEAD
2. `멱등(Idempotent)`
    - 한번 호출하던 두번 호출하던 백번 호출하던 결과가 같아야 한다.
    - 멱등 메서드
        - GET: 한번 조회하든, 두번 조회하든 같은 결과가 조회
        - PUT: 결과를 대체한다. 같은 요청을 여러번 해도 최종 결과는 같다. (없으면 등록, 있으면 완전히 대체하기 때문)
        - DELETE: 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 같다.
            - 최종적으로는 삭제된 상태 유지
    - POST: `멱등이 아니다.` 두번 호출하면 같은 결제가 중복해서 발생할 수 있다.
            - 두번 결제하면 중복 결제
    - 활용
        - 자동 복구 메커니즘
        - timeout 등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 괜찮은가?
    - 재요청 중간에 다른 곳에서 리소스를 변경해 버린다면?
        - 사용자 1번 get → 사용자 2번 put → 사용자 1번 get
        - 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않는다.
3. `캐시 가능(Cacheable)`
    - 응답 결과 리소스를 캐시해서 사용해도 되는가?
    - GET, HEAD, POST, PATCH는 캐시 가능
    - 실제로는 GET이나 HEAD 정도만 캐시로 사용
        - GET, HEAD는 URI만 캐시키로 잡고 구현하면 됨 
        - POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는 문제, 구현이 어려움.
